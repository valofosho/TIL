- Python
    
    표현식(Expression)
    
    - 하나의 ‘값’으로 평가될 수 있는 모든 코드
        - 평가 → 표현식을 계산하여 그 결과인 ‘값’을 만들어내는 과정
    
    값(Value)
    
    - 표현식이 평가된 결과
    - 더 이상 계산되거나 평가될 수 없는, 프로그램의 가장 기본적인 데이터 조각
    
    불리언(Boolean)
    
    - 컴퓨터에서 참과 거짓을 나타내는 숫자 1과 0만을 이용하는 방식
    
    변수(Variable)
    
    - 값을 나중에 다시 사용하기 위해, 그 값에 붙여주는 고유한 이름
    
    변수 할당(Variable Assignment)
    
    - 표현식이 만들어 낸 값에 이름을 붙이는 과정(연결)
    
    변수명 규칙
    
    - 영문 알파벳, 언더스코어, 숫자로 구성
    - 숫자로 시작할 수 없음
    - 대소문자를 구분
    - 아래 키워드는 파이썬의 내부 예약어로 사용할 수 없음
        
    
    메모리 주소
    
    - 컴퓨터가 특정 데이터 값을 정확히 찾아가기 위해 사용하는 기계적인 숫자 주소
    
    객체
    
    - 값, 타입, 그리고 관련된 행동까지 하나로 묶인 개념, 객체는 파이썬에서 다루는 모든 데이터의 실체
    - 값 + 타입 + 주소 정보(메모리)를 묶은 것을 객체(Object)라고 부름
    - 변수는 특정 객체를 ‘가리키는(refer/point to)’ 이름표
    - 변수는 메모리 주소를 ‘가지지(contain)’ 않습니다.
    
    ---
    
    변수
    
    - 값을 나중에 다시 사용하기 위해, 그 값에 붙여주는 고유한 이름
    - “객체를 가리키는 이름”
    
    할당문 동작 순서
    
    ```python
    Variable = expression
    ```
    
    1. 오른쪽 표현식 평가
        - 가장 먼저, 할당 연산자(=)의 오른쪽에 있는 표현식 전체를 계산해 하나의 객체 생성
    2. 왼쪽 변수명 확인
        - 이름이 처음 사용되었다면: 새로운 “이름표”를 준비
        - 이미 존재하는 이름이라면: 기존 “이름표”를 그대로 사용
    3. 변수명과 결과값 연결(참조)
        - 마지막으로 왼쪽의 변수명이 오른쪽에서 만들어진 결과값을 가리키도록 연결
        - 변수명이 이전에 다른 객체를 가리키고 있었다면, 그 연결은 끊어지고 새로운 객체와의 연결만 남음(재할당)
    
    재할당(Reassignment)
    
    - 이미 값이 할당된 변수에 새로운 값을 다시 할당
    
- Data Types
    
    Type
    
    - 변수나 값이 가질 수 있는 데이터의 종류
    - “값”과 “값에 적용할 수 있는 연산”
    
    Data Types
    
    - 값의 종류와 그 값으로 할 수 있는 ‘동작(연산)’을 결정하는 속성
    - 각 타입에 따라 가능한 기능과 연산이 달라 데이터 타입이 필요
- Numeric Types
    
    숫자형 데이터 
    
    1. 정수 자료형(int)
    2. 실수 자료형(float)
        - 지수 표현법
            - big_num = 1.23e9 == (1.23*10^9)
            - small_num = 3.14e-3 == (3.14*10^-3)
    
    숫자형의 ‘행동’ - 산술 연산
    
    - 숫자형 데이터의 핵심 ‘행동’은 바로 계산
    - 데이터 타입은 ‘값의 종류’와 ‘적용 가능한 행동’의 묶음
    - 파이썬은 다양한 계산을 위한 산술 연산자 제공
        
        
        | 기호 | 설명 |
        | --- | --- |
        | + | 덧셈 |
        | - | 뺄셈 |
        | * | 곱셈 |
        | / | 나눗셈 |
        | // | 몫 나눗셈 |
        | % | 나머지 |
        | ** | 거듭제곱 |
        | - | 음수 부호  |
    - 연산자 우선순위
        
        
        | 우선순위 | 연산자 | 연산 |
        | --- | --- | --- |
        | 높음 | ** | 지수 |
        |  | - | 음수 부호 |
        |  | *, /, //, % | 곱셈, 나눗셈, 정수 나눗셈, 나머지 |
        | 낮음 | +, - | 덧셈, 뺄셈 |
- Sequence Type
    - 여러 값들을 순서대로 나열하여 저장하는 자료형
    - Sequence → 여러 데이터가 정해진 순서대로 일렬로 늘어선 자료구조
    - str, list, tuple, range
    - 인덱스(Index) → 시퀀스 자료형에서 각 값의 위치를 식별하기 위해 부여된 고유번호
    - 시퀀스 타입의 5가지 공통 특징
        1. 순서 (Order)
            - 값들이 순서대로 저장(정렬 X)
        2. 인덱싱(Indexing)
            - 각 값에 고유 번호(인덱스)를 가지고 있으며, 인덱스를 사용하여 특정 위치의 값을 선택하거나 수정할 수 있음
        3. 슬라이싱(Slicing)
            - 인덱스 범위를 조절해 전체 데이터 중 원하는 부분만 값을 잘라내서 사용
        4. 길이(Length)
            - len() 함수를 사용하여 저장된 값의 개수(길이)를 구할 수 있음
        5. 반복(Iteration)
            - 반복문을 사용하여 각 값을 하나씩 순서대로 꺼내 사용할 수 있음
        
        ---
        
        시퀀스 타입 특징 예시
        
        - my_data = “hello”
            
            
            | 특징 | 사용 예시 | 결과 |
            | --- | --- | --- |
            | 인덱싱 | my_data[1] | ‘e’ |
            | 슬라이싱 | my_data[1:4] | ‘ell’ |
            | 길이 | len(my_data) | 5 |
            | 반복 | for char in my_data | H, e, l, l, o 가 차례로 출력 |
- str(문자열)
    
    문자열 → 문자들의 순서가 잇는 변경 불가능한 시퀀스 자료형
    
    - 이스케이프 시퀀스(Escape Sequence)
        - 역슬래시(\)와 문자를 조합해 특별한 기능을 수행(e.g. 줄바꿈, 탭)
            
            
            | 예약 문자 | 기능 |
            | --- | --- |
            | \n | 줄 바꿈 |
            | \t | 탭 |
            | \\ | 백슬래시 |
            | \’ | 작은 따옴표 |
            | \” | 큰 따옴표 |
    - 문자열에 값 삽입: f-string
        - 문자열 내에 변수나 표현식의 결과를 손쉽게 삽입
        - 문자열 시작 전 ‘f’ 접두어를 붙이고, 삽입할 부분(표현식)을 중괄호 {}로 감싸줌
    - 시퀀스로서의 문자열
        - 문자열은 시퀀스이므로, 인덱싱, 슬라이싱, 길이 확인, 반복 등 공통 기능 모두 사용
            
            
            | 특징 | 사용 예시 | 결과 | 설명 |
            | --- | --- | --- | --- |
            | 인덱싱 | my_str[1] | ‘e’ | 1번 위치의 글자 선택 |
            | 슬라이싱 | my_str[1:4] | ‘ell’ | 1번부터 4번 앞까지 부분 추출 |
            | 길이 | len(my_str) | 5 | 문자열의 전체 길이 |
            | 반복 | for char in my_str | H, e, l, l, o | 각 문자를 순서대로 처리 |
    
    ---
    
    인덱스
    
    - 시퀀스 자료형에서 각 값의 위치를 식별하기 위해 부여된 고유한 번호
    
    슬라이싱(Slicing)
    
    - 시퀀스의 일부를 잘라내어 새로운 시퀀스를 만드는 작업
    - 대괄호 `[]` 안에 시작 위치, 끝 위치, 간격(step)을 콜론(:)으로 구분하여 지정
        
        `my_sequence[start:stop:step]`
        
        1. start: 슬라이싱을 시작할 인덱스(포함됨)
        2. stop: 슬라이싱을 끝낼 인덱스(포함되지 않음)
        3. step: 몇 개씩 건너뛰며 값을 가져올지에 대한 간격
            
            
            | 사용 예시 | 결과 |
            | --- | --- |
            | my_str[2:4] | ‘ll’ |
            | my_str[:3] | ‘hel’ |
            | my_str[3:] | ‘lo’ |
            | my_str[::2] | ‘hlo’ |
            | mystr[::-1] | ‘olleh’ |
    
    문자열의 불변성
    
    - 문자들의 순서가 있는 변경 불가능한 시퀀스 자료형
        - `'str' object does not support item assignment`
    - 기존의 문자열을 바꾸려면 일부 + 새로운 값을 조합해 새로운 문자열 생성
        
        ```python
        my_str = 'Hello'
        new_str = my_str[0] + 'a' + my_str[2:]
        ---
        my_str = 'Hallo'
        # >>> my_str을 변경한게 아닌 새로운 값으로 '재할당' 한 것
        ```
        
- 참고
    1. 정수형의 진법 표현
        - 파이썬은 코드 내 다양한 진법의 숫자 표현을 위해 특별한 접두사(prefix) 제공
            
            
            | 진법 | 접두사 | 사용하는 숫자/문자 |
            | --- | --- | --- |
            | 2진수(binary) | 0b | 0과 1 |
            | 8진수(octal) | 0o | 0부터 7까지 |
            | 16진수(hexadecimal) | 0x | 0부터 9, a부터 f 까지 |
            
            ```python
            # 2진수 10은 10진수로 2입니다.
            print(0b10)
            # 8진수 30은 10진수로 24입니다.
            print(0o30)
            # 16진수 10은 10진수로 16입니다.
            print(0x10)
            ```
            
    2. 실수의 함정, 부동소수점의 오차
        
        부동소수점 (반올림) 오차 (Floating-point Rounding Error)
        
        - 발생 원인
            1. 컴퓨터는 2진법 사용
            2. 무한 소수의 발생과 근사값 저장
                - 10진수 소수 중 일부(예:0.1)는 2진수로 바꾸면 무한히 반복되는 무한 소수가 됨
                - 0.1(10진수) → 0.0001100110011(2진수)
                - 메모리는 유한하기 때문에, 가장 가까운 근사값으로 잘라서 저장
        - 해결책
            - Decimal 모듈을 활용해 부동소수점 연산의 정확성 보장
            - decimal은 실수를 2진수로 변환하지 않고, 10진수 자체로 정확하게 연산